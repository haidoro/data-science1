# 優良顧客を探せ

ミッション
* ある顧客が銀行口座を開設するかしないかを予測して、キャンペーンを効率化せよ。

予測問題
* 分類問題

評価尺度
* AUC(1がもっとも良い)

今回のモデル
* 決定木モデル

## 基礎分析

`train.shape`で行数と列数の確認ができる。

`train.describe()`で基礎統計量を確認できる。基礎分析を行うと言えば、この関数を使ってデータを確認すると良い。

項目名	意味
count	そのカラムの件数
mean	平均
std		標準偏差
min		最小値
25%		第一四分位数
50%		第二四分位数
75%		第三四分位数
max		最大値

trainの基礎分析結果とtestの基礎分析結果の差異があまりないか確認しておきます。あまりに違うと過学習になる可能性があります。

欠損値の有無

欠損値の有無は`isnull()`関数と`sum()`関数を併用します。

```
train.isnull().sum()
```

## 講座開設者の確認

講座開設者は「y」で表されます。その詳細を確認する場合は次のようにします。

```
train["y"].value_counts()
```

### marital(未婚/既婚)とyのクロス集計

* pd.crosstab関数を使います
* pd.crosstab(X["A"], X["B"])と書いた場合、Aが縦列、Bが横列となります
* 更にオプションとしてmargins=Trueを書くと、総計値のカラムまで作成されるので便利です
* 結果の「divorced」は離婚、 「married」は既婚、「single」は独身のことです。
```
pd.crosstab(train["marital"],train["y"],margins=True)
```

### ageをビニング

数値データを使ってクロス集計する場合はビニングという処理を行う必要があります。例えば年齢を使う場合などです。

* ageは数値データなので、クロス集計をする為にはビニングが必要
* ビニングとは数値データを例えば、グループ①（0より大きい、10以下）、グループ②（10より大きい、20以下）…のように集約すること
* ビニングはpd.cut関数を使います
* オプションには、①ビニングしたいデータ、②どう区切るのか？（例えば[0,10,20]）を書きます

まずtrain["age"]の基本統計量を確認します。

```
train["age"].describe()
```

その後、ビニングした結果を変数`age_bining`に代入しましょう。

```
age_bining = pd.cut(train["age"],[0,20,30,40,50,60,100])
```

age_biningとyを使ってクロス集計を行います。

```
pd.crosstab(age_bining,train["y"],margins=True)
```










